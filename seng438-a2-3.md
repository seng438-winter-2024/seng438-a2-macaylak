**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group: 3                  |
|---------------------------|
| Student 1 Ahmed Abbas     |   
| Student 2 Rimal Rizvi     |   
| Student 3 Mariyah Malik   |   
| Student 4 Macayla Konig   |   

# 1 Introduction
In this lab assignment, our main goal is to explore the fundamentals of automated unit testing, with a specific focus on crafting tests tailored to the distinct requirements of each unit. JUnit, an integral part of the XUnit framework family and a widely used unit testing framework for Java, takes center stage as our primary tool. By the end of this lab, we aim to empower ourselves to create automated test code proficiently using JUnit and other XUnit frameworks, such as NUnit. Additionally, we will learn to seamlessly integrate and work with mock objects in the development of our test code.

It's important to note that this lab is a collaborative effort, meant to be completed as a group. Together, we will navigate through three key sections. The initial phase is designed to familiarize ourselves with the essential concepts. We'll then transition to the creation of unit tests based on the requirements outlined in Javadocs. Finally, the testing journey concludes with the execution of the test suites on various versions of the system under scrutiny, with a meticulous collection of the results.

The tools at our disposal for this lab are JUnit and Javadoc. JUnit, being a popular and free unit testing tool for Java, provides a robust framework for our testing endeavors. Javadoc, on the other hand, serves as the format for storing requirement specifications, aiding in the generation of comprehensive test suites.

# 2 Detailed description of unit test strategy

The unit test strategy for this lab is to develop a comprehensive suite of tests that cover all the requirements outlined in the Javadoc. The strategy is to create a test suite for each method in the source code, with each test suite containing test cases that cover all the partitions identified in the requirements. The test cases will be developed using JUnit, and the test suites will be executed on various versions of the system under scrutiny. The test strategy will be implemented in the following steps:

1. **Familiarize with the requirements**: The first step is to familiarize ourselves with the requirements outlined in the Javadoc. We will carefully read through the requirements and identify the partitions for each method in the source code.

2. **Develop test cases**: The next step is to develop test cases for each partition identified in the requirements. We will use JUnit to create test cases that cover all the partitions for each method in the source code.

3. **Create test suites**: Once the test cases are developed, we will create test suites for each method in the source code. Each test suite will contain test cases that cover all the partitions identified in the requirements.

4. **Execute test suites**: The final step is to execute the test suites on various versions of the system under scrutiny. We will collect the results of the test suites and analyze the test coverage to ensure that all the requirements are covered.

# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
